/* automatically generated by rust-bindgen 0.55.1 */

#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(clippy::enum_variant_names)]
use crate::rtypes::*;

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Allocator {
    _unused: [u8; 0],
}
pub type Allocator_t = Allocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct String_s {
    pub len: usize,
    pub bytes: *mut ::std::os::raw::c_char,
}
pub type String = String_s;
pub type String_t = String;
pub type Iface_t = Iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Message {
    pub _length: i32,
    pub _padding: i32,
    pub _msgbytes: *mut u8,
    pub _capacity: i32,
    pub _adLen: i32,
    pub _ad: *mut u8,
    pub _associatedFd: ::std::os::raw::c_int,
    pub currentIface: *mut Iface,
    pub _alloc: *mut Allocator,
}
pub type Message_t = Message;
extern "C" {
    pub fn Message_new_fromRust(
        messageLength: u32,
        amountOfPadding: u32,
        alloc: *mut Allocator,
    ) -> *mut Message;
}
pub type Iface_Callback = ::std::option::Option<
    unsafe extern "C" fn(message: *mut Message_t, thisInterface: *mut Iface) -> *mut RTypes_Error_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iface {
    pub send: Iface_Callback,
    pub currentMsg: *mut Message_t,
    pub connectedIf: *mut Iface,
    pub Identity_verifier: usize,
}
extern "C" {
    pub fn Iface_incoming_fromRust(
        message: *mut Message_t,
        thisInterface: *mut Iface,
    ) -> *mut RTypes_Error_t;
}
extern "C" {
    pub fn RustIface_gotIncoming_fromRust();
}
extern "C" {
    pub fn RustIface_gotOutgoing_fromRust();
}
extern "C" {
    pub fn RustIface_dropped_fromRust();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Log_Level {
    Log_Level_KEYS = 0,
    Log_Level_DEBUG = 1,
    Log_Level_INFO = 2,
    Log_Level_WARN = 3,
    Log_Level_ERROR = 4,
    Log_Level_CRITICAL = 5,
    Log_Level_INVALID = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Log {
    _unused: [u8; 0],
}
pub type Log_t = Log;
extern "C" {
    pub fn Log_print_fromRust(
        log: *mut Log,
        lvl: Log_Level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Random {
    _unused: [u8; 0],
}
pub type Random_t = Random;
extern "C" {
    pub fn Random_bytes_fromRust(rand: *mut Random_t, location: *mut u8, count: u64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sockaddr {
    pub addrLen: u16,
    pub flags: u8,
    pub type_: u8,
    pub prefix: u8,
    pub pad1: u8,
    pub pad2: u16,
}
pub type Sockaddr_t = Sockaddr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sockaddr_storage {
    pub addr: Sockaddr_t,
    pub nativeAddr: [u64; 16usize],
}
extern "C" {
    pub fn Sockaddr_getPort_fromRust(sockaddr: *const Sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Sockaddr_setPort_fromRust(sockaddr: *mut Sockaddr, port: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Sockaddr_AF_INET: ::std::os::raw::c_int;
}
extern "C" {
    pub static Sockaddr_AF_INET6: ::std::os::raw::c_int;
}
extern "C" {
    pub fn Sockaddr_getFamily_fromRust(sockaddr: *const Sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Sockaddr_asIp6_fromRust(addrOut: *mut u8, sockaddr: *const Sockaddr);
}
extern "C" {
    pub fn Sockaddr_initFromBytes_fromRust(
        out: *mut Sockaddr_storage,
        bytes: *const u8,
        addrFamily: ::std::os::raw::c_int,
    ) -> *mut Sockaddr_t;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CryptoAuth_addUser_Res {
    CryptoAuth_addUser_DUPLICATE = -3,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SwitchHeader {
    pub label_be: u64,
    pub congestAndSuppressErrors: u8,
    pub versionAndLabelShift: u8,
    pub trafficClass_be: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RouteHeader {
    pub publicKey: [u8; 32usize],
    pub sh: SwitchHeader,
    pub version_be: u32,
    pub flags: u8,
    pub unused: u8,
    pub alsoUnused: u16,
    pub ip6: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DataHeader {
    pub versionAndFlags: u8,
    pub unused: u8,
    pub contentType_be: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PFChan_Node {
    pub ip6: [u8; 16usize],
    pub publicKey: [u8; 32usize],
    pub path_be: u64,
    pub metric_be: u32,
    pub version_be: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PFChan_Msg {
    pub route: RouteHeader,
    pub data: DataHeader,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PFChan_Ping {
    pub cookie: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PFChan_Pathfinder_Connect {
    pub superiority_be: u32,
    pub version_be: u32,
    pub userAgent: [u8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PFChan_Pathfinder_Superiority {
    pub superiority_be: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PFChan_Pathfinder_ConnectPeer {
    pub ip: [u8; 16usize],
    pub pubkey: [u8; 32usize],
    pub login: [u8; 16usize],
    pub password: [u8; 24usize],
    pub version: u32,
}
pub type PFChan_Pathfinder_ConnectPeer_t = PFChan_Pathfinder_ConnectPeer;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PFChan_Pathfinder {
    PFChan_Pathfinder__TOO_LOW = 511,
    PFChan_Pathfinder_CONNECT = 512,
    PFChan_Pathfinder_SUPERIORITY = 513,
    PFChan_Pathfinder_NODE = 514,
    PFChan_Pathfinder_SENDMSG = 515,
    PFChan_Pathfinder_PING = 516,
    PFChan_Pathfinder_PONG = 517,
    PFChan_Pathfinder_SESSIONS = 518,
    PFChan_Pathfinder_PEERS = 519,
    PFChan_Pathfinder_PATHFINDERS = 520,
    PFChan_Pathfinder_CTRL_SENDMSG = 521,
    PFChan_Pathfinder_SNODE = 522,
    PFChan_Pathfinder_CONNECT_PEER = 523,
    PFChan_Pathfinder__TOO_HIGH = 524,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PFChan_FromPathfinder {
    pub event_be: PFChan_Pathfinder,
    pub target_be: u8,
    pub content: PFChan_FromPathfinder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PFChan_FromPathfinder__bindgen_ty_1 {
    pub connect: PFChan_Pathfinder_Connect,
    pub superiority: PFChan_Pathfinder_Superiority,
    pub node: PFChan_Node,
    pub sendmsg: PFChan_Msg,
    pub ping: PFChan_Ping,
    pub pong: PFChan_Ping,
    pub cp: PFChan_Pathfinder_ConnectPeer_t,
    pub bytes: [u8; 1usize],
    _bindgen_union_align: [u64; 12usize],
}
pub type PFChan_FromPathfinder_t = PFChan_FromPathfinder;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RBindings_Version {
    RBindings_Version_CurrentProtocol = 22,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RBindings_Whitelist {
    pub b: Iface_t,
    pub c: CryptoAuth_addUser_Res,
    pub d: Message_t,
    pub e: String_t,
    pub f: *mut Log_t,
    pub g: RBindings_Version,
    pub h: Sockaddr_t,
    pub i: PFChan_FromPathfinder_t,
    pub j: Log_Level,
    pub k: *mut Allocator_t,
    pub l: Sockaddr_storage,
    pub m: Sockaddr,
    pub n: *mut Random_t,
}
