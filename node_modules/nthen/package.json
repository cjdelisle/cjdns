{
  "author": {
    "name": "Caleb James DeLisle",
    "email": "cjd@hyperboria.ca",
    "url": "http://cjd.hypebox.net"
  },
  "name": "nthen",
  "description": "Simple intuitive asynchronous control flow.",
  "version": "0.1.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/cjdelisle/nthen"
  },
  "keywords": [
    "async",
    "flow",
    "chaining"
  ],
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/nthen.js",
  "bugs": {
    "url": "http://github.com/cjdelisle/nthen/issues"
  },
  "devDependencies": {
    "tap": "~0.4.0"
  },
  "scripts": {
    "test": "tap ./test"
  },
  "homepage": "https://github.com/cjdelisle/nthen",
  "licenses": [
    {
      "type": "Public Domain"
    }
  ],
  "readme": "# nThen... Do this... nThen... Do that.\n\nnThen is designed to be the most small, simple and intuitive asynchronous library.\n\n## How you used to do things\n\n    x = synchronous_call();\n    y = use(x);\n    a = another_sync_call(x);          # Hey!\n    b = yet_another_sync_call(x);      # these two could run at the same time!\n    z = something_else_synchronous(b);\n    c = last_synchronous_call(z);\n    do_next_job(c);\n\nOk so we learned that doing it that way is slow and we have asynchronous so we never have to be slow anymore.\n\n## The naive asynchronous approach\n\n    var context = {};\n    async_call(function(x) {\n        context.y = use(x);\n        another_call(x, function(a) {\n            context.a = a;\n            if (context.c) { do_next_job(context); }\n        });\n        yet_another_call(x, function(b) {\n            something_else(b, function(z) {\n                last_call(z, function(c) {\n                    context.c = c;\n                    if (context.a) { do_next_job(context); }\n                });\n            });\n        });\n    });\n\nThat doesn't look like very much fun :(\nAnd to make matters worse, what happens if one of those functions never returns?\n\n    var to = setTimeout(function() { abort_process(); }, 3000);\n\nYou can see where this is going.\n\n\n## nThen to the rescue\n\n    var nThen = require('nthen');\n    var context = {};\n    nThen(function(waitFor) {\n        // Remember to wrap all of your async callbacks with waitFor()\n        // otherwise they won't block the next nThen block.\n        asyncCall(waitFor(function(x) {\n            context.x = x;\n        }));\n    }).nThen(function(waitFor) {\n        // These two functions run at the same time :D\n        anotherCall(x, waitFor(function(a) {\n            context.a = a;\n        }));\n        yetAnotherCall(x, waitFor(function(b) {\n            context.b = b;\n        }));\n    }).nThen(function(waitFor) {\n        somethingElse(b, waitFor(function(z) {\n            context.z = z;\n        }));\n    }).nThen(function(waitFor) {\n        lastCall(z, waitFor(function(c) {\n            context.c = c;\n        }));\n    }).nThen(function(waitFor) {\n\n        doNextJob(context);\n\n    }).orTimeout(function(waitFor) {\n\n        // Using the orTimeout() function, you can chain a failure timeout.\n        abortProcess();\n\n    }, 3000).nThen(function(waitFor) {\n        // Finally, you can chain more nThen calls after the timeout\n        // these will be excuted regardless of whether the chain times out or not.\n        // think of ajax.onComplete\n        someFinalCleanup();\n    });\n\n\n## Chaining is Allowed\n\nThis is perfectly ok, your second call to waitFor() will cause the second function\nto block the entry of the next nThen block and it will perform as expected.\n\n    nThen(function(waitFor) {\n        asyncCall(waitFor(function(x) {\n            iWouldReallyRatherChainThisCall(x, waitFor(function(y) {\n                context.y = y;\n            }));\n        }));\n    }).nThen(function(waitFor) {\n\n## Disclamer\n\nThe variable names used in this readme are only for example and to make you mad.\n\n## License\n\nPublic Domain\n\n## ChangeLog\n\n* 1.0 The first versions, practically perfect in every way.\n* 1.1 Ok maybe practically perfect was a stretch, fixed a bug which causes incorrect behavior if\nthe the first nThen function returns synchronously.\n\n    nThen(function(waitFor) {\n        console.log(\"this function returns synchronously\");\n    }).nThen(function(waitFor) {\n        console.log(\"This never gets executed because nThen 1.0 has a bug :(\");\n    });\n",
  "readmeFilename": "readme.md",
  "_id": "nthen@0.1.1",
  "_from": "nthen@~0.1.1"
}
